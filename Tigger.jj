// Options for JavaCC.
options { LOOKAHEAD=1; FORCE_LA_CHECK=true; STATIC=false;}

// Fonction principale
PARSER_BEGIN(Tigger)
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Stack;
import ast.*;

public class Tigger
{
    public static Stack<HashMap<String, Exp>> stack;
    public static void main(String args[]) throws ParseException
    {
        stack = new Stack<HashMap<String, Exp>>();

        Tigger parser = null;
				if(args.length>0) {
          try {
            InputStream is = new FileInputStream(args[0]);
            parser = new Tigger(is);
            parser.mainloop();
          }
            catch(IOException e){
							e.printStackTrace();
					}
				} else {
          while(true){
      			  System.out.println("Please insert an expression:");
	            parser = new Tigger(System.in);
              parser.mainloop();
			    }
        }
    }
}
PARSER_END(Tigger)

// Characters to ignore.
SKIP: { " " | "\r" | "\t" }

// Token specifications.
TOKEN:
{
    < NUMBER: (<DIGIT>)+ ("." (<DIGIT>)*)? >  // A decimal number.
|   < DIGIT: ["0"-"9"] >                      // A decimal digit.
|   < EOL: "\n" >                             // End of line.
|   < PRINT: "print">
|   <IF: "if">
|   <THEN: "then">
|   <ELSE: "else">
|   <LET: "let">
|   <IN: "in">
|   <END: "end">
|   <VAR: "var">
|   < WORD: <LETTER> ((<DIGIT>)* ((<LETTER>)*)?)?>
|   < LETTER: ["a"-"z","A"-"Z"]>
}

// Main lopp: read expressions on a line until end of file.
//     mainloop -> (expression <EOL>)* <EOF>
// System.out.println("pretty-print: "+PrettyPrinter.visit(a));
// System.out.println("eval: "+Evaluateur.visit(a)+"\n");
void mainloop():
{ Exp a; }
{
    (//Print the result
    <PRINT> "(" a = letInEnd() ")" <EOL> {
      System.out.println("pretty-print: " + PrettyPrinter.visit(a));
      System.out.println("eval: "+Evaluateur.visit(a) + "\n");
    }
     )*
     <EOF>

  | (//Don't print the result
      a = letInEnd() <EOL> {
        if(a!=null){
          System.out.println("pretty-print: "+PrettyPrinter.visit(a));
          System.out.println("eval: "+Evaluateur.visit(a) + "\n");
        }
      }
    )*
    <EOF>
}

Exp letInEnd():
{Token t; Exp a=null; Exp b; }
{
  <LET> {HashMap<String, Exp> scope = new HashMap<String, Exp>();
        stack.push(scope);}
  ("var" t=<WORD> ":=" b=ifThenElse() {Exp exist = scope.put(t.toString(), b);
                                          if(exist != null){
                                            System.out.println("This variable already exists...");
                                            System.exit(0);
                                          }}
  )*
  <IN> (a=ifThenElse())* <END> {return a;}
}

//E -> T(+T|-T)
//T -> F(*F|/F)
//F -> <NUM> |(E)

Exp ifThenElse():
{Exp a,b,c;}
{
  (//In case there is an if then else operator
    <IF> a = ifThenElse() <THEN> b = ifThenElse() <ELSE> c=ifThenElse() {if(Evaluateur.visit(a)==1){return b;}else return c;}
  )
  |(//In case there is no if then else operator
    a = comp() {return a;}
  ) {return a;}
}


Exp comp():
{Exp a,b;}
{
  a = expression()
  (
    "="  b = expression() {a = new Eq(a,b);}
  | "<>" b = expression() {a = new Ne(a,b);}
  | "<=" b = expression() {a = new Le(a,b);}
  | "<"  b = expression() {a = new Lt(a,b);}
  | ">=" b = expression() {a = new Ge(a,b);}
  | ">"  b = expression() {a = new Gt(a,b);}
  | {return a;} // if we haven't any comparison to do
  ) {return a;}
}

Exp expression():
{Exp a,b;}
{
	a = term()
	(
		"+" b=term() {a= new Add(a,b);}
	|	"-" b=term() {a= new Sub(a,b);}
	)*	{return a;}
}

Exp term():
{Exp a,b;}
{
	a = change()
	(
		"*" b=change() {a= new Mul(a,b);}
	|	"/" b=change() {a= new Div(a,b);}
	)*	{return a;}
}

Exp var():
{Token t; Exp a, b;}
{
  t = <WORD> {
    Stack<HashMap<String, Exp>> s = (Stack<HashMap<String, Exp>>) stack.clone();
    HashMap<String, Exp> l;
    while(!s.empty()) {
      l = (HashMap<String, Exp>) s.pop();
      if(l.containsKey(t.toString())) {
        Var v = new Var(t.toString(), l.get(t.toString()));
        return v;
      }
    }
    System.out.println("Variable " + t.toString() + " does not exist !!");
    System.exit(0);
  }
}

Exp change():
{Exp a;}
{
  a = unary() {return a;}
  | a = var() {return a;}
}

Exp unary():
{Token t; Exp a;}
{
    t=<NUMBER> { return new Num(Double.parseDouble(t.toString())); }
|	(
    "+" a = factor() {a = new Plus(a);}
  | "-" a = factor() {a = new Minus(a);}
  ){return a;}
| (
    "(" a=expression()
    ")" {return a;}
  )
}

// Factor of an expression.
Exp factor():
{ Token t; Exp a; }
{
    t=<NUMBER> { return new Num(Double.parseDouble(t.toString())); }
|	(
		"("	a=expression()
		")" {return a;}
	)
}

/*
Make AST :
/Exp/
	/Bin/ Exp Exp
		Add
		Sub
		Mul
		Div
	Num double
*/
